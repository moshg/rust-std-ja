<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="what-is-rustdoc.html"><strong aria-hidden="true">1.</strong> What is rustdoc?</a></li><li><a href="command-line-arguments.html"><strong aria-hidden="true">2.</strong> Command-line arguments</a></li><li><a href="the-doc-attribute.html"><strong aria-hidden="true">3.</strong> The #[doc] attribute</a></li><li><a href="documentation-tests.html"><strong aria-hidden="true">4.</strong> Documentation tests</a></li><li><a href="passes.html"><strong aria-hidden="true">5.</strong> Passes</a></li><li><a href="unstable-features.html"><strong aria-hidden="true">6.</strong> Unstable features</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#what-is-rustdoc" id="what-is-rustdoc"><h1>What is rustdoc?</h1></a>
<p>The standard Rust distribution ships with a tool called <code>rustdoc</code>. Its job is
to generate documentation for Rust projects. On a fundamental level, Rustdoc
takes as an argument either a crate root or a Markdown file, and produces HTML,
CSS, and JavaScript.</p>
<a class="header" href="print.html#basic-usage" id="basic-usage"><h2>Basic usage</h2></a>
<p>Let's give it a try! Let's create a new project with Cargo:</p>
<pre><code class="language-bash">$ cargo new docs
$ cd docs
</code></pre>
<p>In <code>src/lib.rs</code>, you'll find that Cargo has generated some sample code. Delete
it and replace it with this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// foo is a function
fn foo() {}
#}</code></pre></pre>
<p>Let's run <code>rustdoc</code> on our code. To do so, we can call it with the path to
our crate root like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs
</code></pre>
<p>This will create a new directory, <code>doc</code>, with a website inside! In our case,
the main page is located in <code>doc/lib/index.html</code>. If you open that up in
a web browser, you'll see a page with a search bar, and &quot;Crate lib&quot; at the
top, with no contents. There's two problems with this: first, why does it
think that our package is named &quot;lib&quot;? Second, why does it not have any
contents?</p>
<p>The first problem is due to <code>rustdoc</code> trying to be helpful; like <code>rustc</code>,
it assumes that our crate's name is the name of the file for the crate
root. To fix this, we can pass in a command-line flag:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --crate-name docs
</code></pre>
<p>Now, <code>doc/docs/index.html</code> will be generated, and the page says &quot;Crate docs.&quot;</p>
<p>For the second issue, it's because our function <code>foo</code> is not public; <code>rustdoc</code>
defaults to generating documentation for only public functions. If we change
our code...</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// foo is a function
pub fn foo() {}
#}</code></pre></pre>
<p>... and then re-run <code>rustdoc</code>:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --crate-name docs
</code></pre>
<p>We'll have some generated documentation. Open up <code>doc/docs/index.html</code> and
check it out! It should show a link to the <code>foo</code> function's page, which
is located at <code>doc/docs/fn.foo.html</code>. On that page, you'll see the &quot;foo is
a function&quot; we put inside the documentation comment in our crate.</p>
<a class="header" href="print.html#using-rustdoc-with-cargo" id="using-rustdoc-with-cargo"><h2>Using rustdoc with Cargo</h2></a>
<p>Cargo also has integration with <code>rustdoc</code> to make it easier to generate
docs. Instead of the <code>rustdoc</code> command, we could have done this:</p>
<pre><code class="language-bash">$ cargo doc
</code></pre>
<p>Internally, this calls out to <code>rustdoc</code> like this:</p>
<pre><code class="language-bash">$ rustdoc --crate-name docs srclib.rs -o &lt;path&gt;\docs\target\doc -L
dependency=&lt;path&gt;docs\target\debug\deps
</code></pre>
<p>You can see this with <code>cargo doc --verbose</code>.</p>
<p>It generates the correct <code>--crate-name</code> for us, as well as pointing to
<code>src/lib.rs</code> But what about those other arguments? <code>-o</code> controls the
<em>o</em>utput of our docs. Instead of a top-level <code>doc</code> directory, you'll
notice that Cargo puts generated documentation under <code>target</code>. That's
the idiomatic place for generated files in Cargo projects. Also, it
passes <code>-L</code>, a flag that helps rustdoc find the dependencies
your code relies on. If our project used dependencies, we'd get
documentation for them as well!</p>
<a class="header" href="print.html#using-standalone-markdown-files" id="using-standalone-markdown-files"><h2>Using standalone Markdown files</h2></a>
<p><code>rustdoc</code> can also generate HTML from standalone Markdown files. Let's
give it a try: create a <code>README.md</code> file with these contents:</p>
<pre><code class="language-text">    # Docs

    This is a project to test out `rustdoc`.

    [Here is a link!](https://www.rust-lang.org)

    ## Subheading

    ```rust
    fn foo() -&gt; i32 {
        1 + 1
    }
    ```
</code></pre>
<p>And call <code>rustdoc</code> on it:</p>
<pre><code class="language-bash">$ rustdoc README.md
</code></pre>
<p>You'll find an HTML file in <code>docs/doc/README.html</code> generated from its
Markdown contents.</p>
<p>Cargo currently does not understand standalone Markdown files, unfortunately.</p>
<a class="header" href="print.html#summary" id="summary"><h2>Summary</h2></a>
<p>This covers the simplest use-cases of <code>rustdoc</code>. The rest of this book will
explain all of the options that <code>rustdoc</code> has, and how to use them.</p>
<a class="header" href="print.html#command-line-arguments" id="command-line-arguments"><h1>Command-line arguments</h1></a>
<p>Here's the list of arguments you can pass to <code>rustdoc</code>:</p>
<a class="header" href="print.html#a-h--help-help" id="a-h--help-help"><h2><code>-h</code>/<code>--help</code>: help</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc -h
$ rustdoc --help
</code></pre>
<p>This will show <code>rustdoc</code>'s built-in help, which largely consists of
a list of possible command-line flags.</p>
<p>Some of <code>rustdoc</code>'s flags are unstable; this page only shows stable
options, <code>--help</code> will show them all.</p>
<a class="header" href="print.html#a-v--version-version-information" id="a-v--version-version-information"><h2><code>-V</code>/<code>--version</code>: version information</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc -V
$ rustdoc --version
</code></pre>
<p>This will show <code>rustdoc</code>'s version, which will look something
like this:</p>
<pre><code class="language-text">rustdoc 1.17.0 (56124baa9 2017-04-24)
</code></pre>
<a class="header" href="print.html#a-v--verbose-more-verbose-output" id="a-v--verbose-more-verbose-output"><h2><code>-v</code>/<code>--verbose</code>: more verbose output</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc -v src/lib.rs
$ rustdoc --verbose src/lib.rs
</code></pre>
<p>This enables &quot;verbose mode&quot;, which means that more information will be written
to standard out. What is written depends on the other flags you've passed in.
For example, with <code>--version</code>:</p>
<pre><code class="language-text">$ rustdoc --verbose --version
rustdoc 1.17.0 (56124baa9 2017-04-24)
binary: rustdoc
commit-hash: hash
commit-date: date
host: host-triple
release: 1.17.0
LLVM version: 3.9
</code></pre>
<a class="header" href="print.html#a-r--input-format-input-format" id="a-r--input-format-input-format"><h2><code>-r</code>/<code>--input-format</code>: input format</h2></a>
<p>This flag is currently ignored; the idea is that <code>rustdoc</code> would support various
input formats, and you could specify them via this flag.</p>
<p>Rustdoc only supports Rust source code and Markdown input formats. If the
file ends in <code>.md</code> or <code>.markdown</code>, <code>rustdoc</code> treats it as a Markdown file.
Otherwise, it assumes that the input file is Rust.</p>
<a class="header" href="print.html#a-w--output-format-output-format" id="a-w--output-format-output-format"><h2><code>-w</code>/<code>--output-format</code>: output format</h2></a>
<p>This flag is currently ignored; the idea is that <code>rustdoc</code> would support
various output formats, and you could specify them via this flag.</p>
<p>Rustdoc only supports HTML output, and so this flag is redundant today.</p>
<a class="header" href="print.html#a-o--output-output-path" id="a-o--output-output-path"><h2><code>-o</code>/<code>--output</code>: output path</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -o target\\doc
$ rustdoc src/lib.rs --output target\\doc
</code></pre>
<p>By default, <code>rustdoc</code>'s output appears in a directory named <code>doc</code> in
the current working directory. With this flag, it will place all output
into the directory you specify.</p>
<a class="header" href="print.html#a--crate-name-controlling-the-name-of-the-crate" id="a--crate-name-controlling-the-name-of-the-crate"><h2><code>--crate-name</code>: controlling the name of the crate</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --crate-name mycrate
</code></pre>
<p>By default, <code>rustdoc</code> assumes that the name of your crate is the same name
as the <code>.rs</code> file. <code>--crate-name</code> lets you override this assumption with
whatever name you choose.</p>
<a class="header" href="print.html#a-l--library-path-where-to-look-for-dependencies" id="a-l--library-path-where-to-look-for-dependencies"><h2><code>-L</code>/<code>--library-path</code>: where to look for dependencies</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -L target/debug/deps
$ rustdoc src/lib.rs --library-path target/debug/deps
</code></pre>
<p>If your crate has dependencies, <code>rustdoc</code> needs to know where to find them.
Passing <code>--library-path</code> gives <code>rustdoc</code> a list of places to look for these
dependencies.</p>
<p>This flag takes any number of directories as its argument, and will use all of
them when searching.</p>
<a class="header" href="print.html#a--cfg-passing-configuration-flags" id="a--cfg-passing-configuration-flags"><h2><code>--cfg</code>: passing configuration flags</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --cfg feature=&quot;foo&quot;
</code></pre>
<p>This flag accepts the same values as <code>rustc --cfg</code>, and uses it to configure
compilation. The example above uses <code>feature</code>, but any of the <code>cfg</code> values
are acceptable.</p>
<a class="header" href="print.html#a--extern-specify-a-dependencys-location" id="a--extern-specify-a-dependencys-location"><h2><code>--extern</code>: specify a dependency's location</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --extern lazy-static=/path/to/lazy-static
</code></pre>
<p>Similar to <code>--library-path</code>, <code>--extern</code> is about specifying the location
of a dependency. <code>--library-path</code> provides directories to search in, <code>--extern</code>
instead lets you specify exactly which dependency is located where.</p>
<a class="header" href="print.html#a-c--codegen-pass-codegen-options-to-rustc" id="a-c--codegen-pass-codegen-options-to-rustc"><h2><code>-C</code>/<code>--codegen</code>: pass codegen options to rustc</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -C target_feature=+avx
$ rustdoc src/lib.rs --codegen target_feature=+avx

$ rustdoc --test src/lib.rs -C target_feature=+avx
$ rustdoc --test src/lib.rs --codegen target_feature=+avx

$ rustdoc --test README.md -C target_feature=+avx
$ rustdoc --test README.md --codegen target_feature=+avx
</code></pre>
<p>When rustdoc generates documentation, looks for documentation tests, or executes documentation
tests, it needs to compile some rust code, at least part-way. This flag allows you to tell rustdoc
to provide some extra codegen options to rustc when it runs these compilations. Most of the time,
these options won't affect a regular documentation run, but if something depends on target features
to be enabled, or documentation tests need to use some additional options, this flag allows you to
affect that.</p>
<p>The arguments to this flag are the same as those for the <code>-C</code> flag on rustc. Run <code>rustc -C help</code> to
get the full list.</p>
<a class="header" href="print.html#a--passes-add-more-rustdoc-passes" id="a--passes-add-more-rustdoc-passes"><h2><code>--passes</code>: add more rustdoc passes</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc --passes list
$ rustdoc src/lib.rs --passes strip-priv-imports
</code></pre>
<p>An argument of &quot;list&quot; will print a list of possible &quot;rustdoc passes&quot;, and other
arguments will be the name of which passes to run in addition to the defaults.</p>
<p>For more details on passes, see <a href="passes.html">the chapter on them</a>.</p>
<p>See also <code>--no-defaults</code>.</p>
<a class="header" href="print.html#a--no-defaults-dont-run-default-passes" id="a--no-defaults-dont-run-default-passes"><h2><code>--no-defaults</code>: don't run default passes</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --no-defaults
</code></pre>
<p>By default, <code>rustdoc</code> will run several passes over your code. This
removes those defaults, allowing you to use <code>--passes</code> to specify
exactly which passes you want.</p>
<p>For more details on passes, see <a href="passes.html">the chapter on them</a>.</p>
<p>See also <code>--passes</code>.</p>
<a class="header" href="print.html#a--test-run-code-examples-as-tests" id="a--test-run-code-examples-as-tests"><h2><code>--test</code>: run code examples as tests</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --test
</code></pre>
<p>This flag will run your code examples as tests. For more, see <a href="documentation-tests.html">the chapter
on documentation tests</a>.</p>
<p>See also <code>--test-args</code>.</p>
<a class="header" href="print.html#a--test-args-pass-options-to-test-runner" id="a--test-args-pass-options-to-test-runner"><h2><code>--test-args</code>: pass options to test runner</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --test --test-args ignored
</code></pre>
<p>This flag will pass options to the test runner when running documentation tests.
For more, see <a href="documentation-tests.html">the chapter on documentation tests</a>.</p>
<p>See also <code>--test</code>.</p>
<a class="header" href="print.html#a--target-generate-documentation-for-the-specified-target-triple" id="a--target-generate-documentation-for-the-specified-target-triple"><h2><code>--target</code>: generate documentation for the specified target triple</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --target x86_64-pc-windows-gnu
</code></pre>
<p>Similar to the <code>--target</code> flag for <code>rustc</code>, this generates documentation
for a target triple that's different than your host triple.</p>
<p>All of the usual caveats of cross-compiling code apply.</p>
<a class="header" href="print.html#a--markdown-css-include-more-css-files-when-rendering-markdown" id="a--markdown-css-include-more-css-files-when-rendering-markdown"><h2><code>--markdown-css</code>: include more CSS files when rendering markdown</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc README.md --markdown-css foo.css
</code></pre>
<p>When rendering Markdown files, this will create a <code>&lt;link&gt;</code> element in the
<code>&lt;head&gt;</code> section of the generated HTML. For example, with the invocation above,</p>
<pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;foo.css&quot;&gt;
</code></pre>
<p>will be added.</p>
<p>When rendering Rust files, this flag is ignored.</p>
<a class="header" href="print.html#a--html-in-header-include-more-html-in-head" id="a--html-in-header-include-more-html-in-head"><h2><code>--html-in-header</code>: include more HTML in <head></h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --html-in-header header.html
$ rustdoc README.md --html-in-header header.html
</code></pre>
<p>This flag takes a list of files, and inserts them into the <code>&lt;head&gt;</code> section of
the rendered documentation.</p>
<a class="header" href="print.html#a--html-before-content-include-more-html-before-the-content" id="a--html-before-content-include-more-html-before-the-content"><h2><code>--html-before-content</code>: include more HTML before the content</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --html-before-content extra.html
$ rustdoc README.md --html-before-content extra.html
</code></pre>
<p>This flag takes a list of files, and inserts them inside the <code>&lt;body&gt;</code> tag but
before the other content <code>rustdoc</code> would normally produce in the rendered
documentation.</p>
<a class="header" href="print.html#a--html-after-content-include-more-html-after-the-content" id="a--html-after-content-include-more-html-after-the-content"><h2><code>--html-after-content</code>: include more HTML after the content</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --html-after-content extra.html
$ rustdoc README.md --html-after-content extra.html
</code></pre>
<p>This flag takes a list of files, and inserts them before the <code>&lt;/body&gt;</code> tag but
after the other content <code>rustdoc</code> would normally produce in the rendered
documentation.</p>
<a class="header" href="print.html#a--markdown-playground-url-control-the-location-of-the-playground" id="a--markdown-playground-url-control-the-location-of-the-playground"><h2><code>--markdown-playground-url</code>: control the location of the playground</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc README.md --markdown-playground-url https://play.rust-lang.org/
</code></pre>
<p>When rendering a Markdown file, this flag gives the base URL of the Rust
Playground, to use for generating <code>Run</code> buttons.</p>
<a class="header" href="print.html#a--markdown-no-toc-dont-generate-a-table-of-contents" id="a--markdown-no-toc-dont-generate-a-table-of-contents"><h2><code>--markdown-no-toc</code>: don't generate a table of contents</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc README.md --markdown-no-toc
</code></pre>
<p>When generating documentation from a Markdown file, by default, <code>rustdoc</code> will
generate a table of contents. This flag suppresses that, and no TOC will be
generated.</p>
<a class="header" href="print.html#a-e--extend-css-extend-rustdocs-css" id="a-e--extend-css-extend-rustdocs-css"><h2><code>-e</code>/<code>--extend-css</code>: extend rustdoc's CSS</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -e extra.css
$ rustdoc src/lib.rs --extend-css extra.css
</code></pre>
<p>With this flag, the contents of the files you pass are included at the bottom
of Rustdoc's <code>theme.css</code> file.</p>
<p>While this flag is stable, the contents of <code>theme.css</code> are not, so be careful!
Updates may break your theme extensions.</p>
<a class="header" href="print.html#a--sysroot-override-the-system-root" id="a--sysroot-override-the-system-root"><h2><code>--sysroot</code>: override the system root</h2></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs --sysroot /path/to/sysroot
</code></pre>
<p>Similar to <code>rustc --sysroot</code>, this lets you change the sysroot <code>rustdoc</code> uses
when compiling your code.</p>
<a class="header" href="print.html#the-doc-attribute" id="the-doc-attribute"><h1>The <code>#[doc]</code> attribute</h1></a>
<p>The <code>#[doc]</code> attribute lets you control various aspects of how <code>rustdoc</code> does
its job.</p>
<p>The most basic function of <code>#[doc]</code> is to handle the actual documentation
text. That is, <code>///</code> is syntax sugar for <code>#[doc]</code>. This means that these two
are the same:</p>
<pre><code class="language-rust ignore">/// This is a doc comment.
#[doc = &quot; This is a doc comment.&quot;]
</code></pre>
<p>(Note the leading space in the attribute version.)</p>
<p>In most cases, <code>///</code> is easier to use than <code>#[doc]</code>. One case where the latter is easier is
when generating documentation in macros; the <code>collapse-docs</code> pass will combine multiple
<code>#[doc]</code> attributes into a single doc comment, letting you generate code like this:</p>
<pre><code class="language-rust ignore">#[doc = &quot;This is&quot;]
#[doc = &quot; a &quot;]
#[doc = &quot;doc comment&quot;]
</code></pre>
<p>Which can feel more flexible. Note that this would generate this:</p>
<pre><code class="language-rust ignore">#[doc = &quot;This is\n a \ndoc comment&quot;]
</code></pre>
<p>but given that docs are rendered via Markdown, it will remove these newlines.</p>
<p>The <code>doc</code> attribute has more options though! These don't involve the text of
the output, but instead, various aspects of the presentation of the output.
We've split them into two kinds below: attributes that are useful at the
crate level, and ones that are useful at the item level.</p>
<a class="header" href="print.html#at-the-crate-level" id="at-the-crate-level"><h2>At the crate level</h2></a>
<p>These options control how the docs look at a macro level.</p>
<a class="header" href="print.html#html_favicon_url" id="html_favicon_url"><h3><code>html_favicon_url</code></h3></a>
<p>This form of the <code>doc</code> attribute lets you control the favicon of your docs.</p>
<pre><code class="language-rust ignore">#![doc(html_favicon_url = &quot;https://example.com/favicon.ico&quot;)]
</code></pre>
<p>This will put <code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;{}&quot;&gt;</code> into your docs, where
the string for the attribute goes into the <code>{}</code>.</p>
<p>If you don't use this attribute, there will be no favicon.</p>
<a class="header" href="print.html#html_logo_url" id="html_logo_url"><h3><code>html_logo_url</code></h3></a>
<p>This form of the <code>doc</code> attribute lets you control the logo in the upper
left hand side of the docs.</p>
<pre><code class="language-rust ignore">#![doc(html_logo_url = &quot;https://example.com/logo.jpg&quot;)]
</code></pre>
<p>This will put <code>&lt;a href='index.html'&gt;&lt;img src='{}' alt='logo' width='100'&gt;&lt;/a&gt;</code> into
your docs, where the string for the attribute goes into the <code>{}</code>.</p>
<p>If you don't use this attribute, there will be no logo.</p>
<a class="header" href="print.html#html_playground_url" id="html_playground_url"><h3><code>html_playground_url</code></h3></a>
<p>This form of the <code>doc</code> attribute lets you control where the &quot;run&quot; buttons
on your documentation examples make requests to.</p>
<pre><code class="language-rust ignore">#![doc(html_playground_url = &quot;https://playground.example.com/&quot;)]
</code></pre>
<p>Now, when you press &quot;run&quot;, the button will make a request to this domain.</p>
<p>If you don't use this attribute, there will be no run buttons.</p>
<a class="header" href="print.html#issue_tracker_base_url" id="issue_tracker_base_url"><h3><code>issue_tracker_base_url</code></h3></a>
<p>This form of the <code>doc</code> attribute is mostly only useful for the standard library;
When a feature is unstable, an issue number for tracking the feature must be
given. <code>rustdoc</code> uses this number, plus the base URL given here, to link to
the tracking issue.</p>
<pre><code class="language-rust ignore">#![doc(issue_tracker_base_url = &quot;https://github.com/rust-lang/rust/issues/&quot;)]
</code></pre>
<a class="header" href="print.html#html_no_source" id="html_no_source"><h3><code>html_no_source</code></h3></a>
<p>By default, <code>rustdoc</code> will include the source code of your program, with links
to it in the docs. But if you include this:</p>
<pre><code class="language-rust ignore">#![doc(html_no_source)]
</code></pre>
<p>it will not.</p>
<a class="header" href="print.html#testno_crate_inject" id="testno_crate_inject"><h3><code>test(no_crate_inject)</code></h3></a>
<p>By default, <code>rustdoc</code> will automatically add a line with <code>extern crate my_crate;</code> into each doctest.
But if you include this:</p>
<pre><code class="language-rust ignore">#![doc(test(no_crate_inject))]
</code></pre>
<p>it will not.</p>
<a class="header" href="print.html#testattr" id="testattr"><h3><code>test(attr(...))</code></h3></a>
<p>This form of the <code>doc</code> attribute allows you to add arbitrary attributes to all your doctests. For
example, if you want your doctests to fail if they produce any warnings, you could add this:</p>
<pre><code class="language-rust ignore">#![doc(test(attr(deny(warnings))))]
</code></pre>
<a class="header" href="print.html#at-the-item-level" id="at-the-item-level"><h2>At the item level</h2></a>
<p>These forms of the <code>#[doc]</code> attribute are used on individual items, to control how
they are documented.</p>
<a class="header" href="print.html#docno_inlinedocinline" id="docno_inlinedocinline"><h2><code>#[doc(no_inline)]</code>/<code>#[doc(inline)]</code></h2></a>
<p>These attributes are used on <code>use</code> statements, and control where the documentation shows
up. For example, consider this Rust code:</p>
<pre><code class="language-rust ignore">pub use bar::Bar;

/// bar docs
pub mod bar {
    /// the docs for Bar
    pub struct Bar;
}
</code></pre>
<p>The documentation will generate a &quot;Re-exports&quot; section, and say <code>pub use bar::Bar;</code>, where
<code>Bar</code> is a link to its page.</p>
<p>If we change the <code>use</code> line like this:</p>
<pre><code class="language-rust ignore">#[doc(inline)]
pub use bar::Bar;
</code></pre>
<p>Instead, <code>Bar</code> will appear in a <code>Structs</code> section, just like <code>Bar</code> was defined at the
top level, rather than <code>pub use</code>'d.</p>
<p>Let's change our original example, by making <code>bar</code> private:</p>
<pre><code class="language-rust ignore">pub use bar::Bar;

/// bar docs
mod bar {
    /// the docs for Bar
    pub struct Bar;
}
</code></pre>
<p>Here, because <code>bar</code> is not public, <code>Bar</code> wouldn't have its own page, so there's nowhere
to link to. <code>rustdoc</code> will inline these definitions, and so we end up in the same case
as the <code>#[doc(inline)]</code> above; <code>Bar</code> is in a <code>Structs</code> section, as if it were defined at
the top level. If we add the <code>no_inline</code> form of the attribute:</p>
<pre><code class="language-rust ignore">#[doc(no_inline)]
pub use bar::Bar;

/// bar docs
mod bar {
    /// the docs for Bar
    pub struct Bar;
}
</code></pre>
<p>Now we'll have a <code>Re-exports</code> line, and <code>Bar</code> will not link to anywhere.</p>
<a class="header" href="print.html#dochidden" id="dochidden"><h2><code>#[doc(hidden)]</code></h2></a>
<p>Any item annotated with <code>#[doc(hidden)]</code> will not appear in the documentation, unless
the <code>strip-hidden</code> pass is removed.</p>
<a class="header" href="print.html#docprimitive" id="docprimitive"><h2><code>#[doc(primitive)]</code></h2></a>
<p>Since primitive types are defined in the compiler, there's no place to attach documentation
attributes. This attribute is used by the standard library to provide a way to generate
documentation for primitive types.</p>
<a class="header" href="print.html#documentation-tests" id="documentation-tests"><h1>Documentation tests</h1></a>
<p><code>rustdoc</code> supports executing your documentation examples as tests. This makes sure
that your tests are up to date and working.</p>
<p>The basic idea is this:</p>
<pre><code class="language-ignore">/// # Examples
///
/// ```
/// let x = 5;
/// ```
</code></pre>
<p>The triple backticks start and end code blocks. If this were in a file named <code>foo.rs</code>,
running <code>rustdoc --test foo.rs</code> will extract this example, and then run it as a test.</p>
<p>Please note that by default, if no language is set for the block code, <code>rustdoc</code>
assumes it is <code>Rust</code> code. So the following:</p>
<pre><code class="language-markdown">```rust
let x = 5;
```
</code></pre>
<p>is strictly equivalent to:</p>
<pre><code class="language-markdown">```
let x = 5;
```
</code></pre>
<p>There's some subtlety though! Read on for more details.</p>
<a class="header" href="print.html#passing-or-failing-a-doctest" id="passing-or-failing-a-doctest"><h2>Passing or failing a doctest</h2></a>
<p>Like regular unit tests, regular doctests are considered to &quot;pass&quot;
if they compile and run without panicking.
So if you want to demonstrate that some computation gives a certain result,
the <code>assert!</code> family of macros works the same as other Rust code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = &quot;foo&quot;;

assert_eq!(foo, &quot;foo&quot;);
#}</code></pre></pre>
<p>This way, if the computation ever returns something different,
the code panics and the doctest fails.</p>
<a class="header" href="print.html#pre-processing-examples" id="pre-processing-examples"><h2>Pre-processing examples</h2></a>
<p>In the example above, you'll note something strange: there's no <code>main</code>
function! Forcing you to write <code>main</code> for every example, no matter how small,
adds friction. So <code>rustdoc</code> processes your examples slightly before
running them. Here's the full algorithm rustdoc uses to preprocess examples:</p>
<ol>
<li>Some common <code>allow</code> attributes are inserted, including
<code>unused_variables</code>, <code>unused_assignments</code>, <code>unused_mut</code>,
<code>unused_attributes</code>, and <code>dead_code</code>. Small examples often trigger
these lints.</li>
<li>Any attributes specified with <code>#![doc(test(attr(...)))]</code> are added.</li>
<li>Any leading <code>#![foo]</code> attributes are left intact as crate attributes.</li>
<li>If the example does not contain <code>extern crate</code>, and
<code>#![doc(test(no_crate_inject))]</code> was not specified, then <code>extern crate &lt;mycrate&gt;;</code> is inserted (note the lack of <code>#[macro_use]</code>).</li>
<li>Finally, if the example does not contain <code>fn main</code>, the remainder of the
text is wrapped in <code>fn main() { your_code }</code>.</li>
</ol>
<p>For more about that caveat in rule 4, see &quot;Documenting Macros&quot; below.</p>
<a class="header" href="print.html#hiding-portions-of-the-example" id="hiding-portions-of-the-example"><h2>Hiding portions of the example</h2></a>
<p>Sometimes, you need some setup code, or other things that would distract
from your example, but are important to make the tests work. Consider
an example block that looks like this:</p>
<pre><code class="language-text">/// /// Some documentation.
/// # fn foo() {} // this function will be hidden
/// println!(&quot;Hello, World!&quot;);
</code></pre>
<p>It will render like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Some documentation.
# fn foo() {}
println!(&quot;Hello, World!&quot;);
#}</code></pre></pre>
<p>Yes, that's right: you can add lines that start with <code>#</code>, and they will
be hidden from the output, but will be used when compiling your code. You
can use this to your advantage. In this case, documentation comments need
to apply to some kind of function, so if I want to show you just a
documentation comment, I need to add a little function definition below
it. At the same time, it's only there to satisfy the compiler, so hiding
it makes the example more clear. You can use this technique to explain
longer examples in detail, while still preserving the testability of your
documentation.</p>
<p>For example, imagine that we wanted to document this code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 6;
println!(&quot;{}&quot;, x + y);
#}</code></pre></pre>
<p>We might want the documentation to end up looking like this:</p>
<blockquote>
<p>First, we set <code>x</code> to five:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
# let y = 6;
# println!(&quot;{}&quot;, x + y);
#}</code></pre></pre>
<p>Next, we set <code>y</code> to six:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let x = 5;
let y = 6;
# println!(&quot;{}&quot;, x + y);
#}</code></pre></pre>
<p>Finally, we print the sum of <code>x</code> and <code>y</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let x = 5;
# let y = 6;
println!(&quot;{}&quot;, x + y);
#}</code></pre></pre>
</blockquote>
<p>To keep each code block testable, we want the whole program in each block, but
we don't want the reader to see every line every time.  Here's what we put in
our source code:</p>
<pre><code class="language-markdown">First, we set `x` to five:

```
let x = 5;
# let y = 6;
# println!(&quot;{}&quot;, x + y);
```

Next, we set `y` to six:

```
# let x = 5;
let y = 6;
# println!(&quot;{}&quot;, x + y);
```

Finally, we print the sum of `x` and `y`:

```
# let x = 5;
# let y = 6;
println!(&quot;{}&quot;, x + y);
```
</code></pre>
<p>By repeating all parts of the example, you can ensure that your example still
compiles, while only showing the parts that are relevant to that part of your
explanation.</p>
<a class="header" href="print.html#using--in-doc-tests" id="using--in-doc-tests"><h2>Using <code>?</code> in doc tests</h2></a>
<p>When writing an example, it is rarely useful to include a complete error
handling, as it would add significant amounts of boilerplate code. Instead, you
may want the following:</p>
<pre><code class="language-ignore">/// ```
/// use std::io;
/// let mut input = String::new();
/// io::stdin().read_line(&amp;mut input)?;
/// ```
</code></pre>
<p>The problem is that <code>?</code> returns a <code>Result&lt;T, E&gt;</code> and test functions don't
return anything, so this will give a mismatched types error.</p>
<p>You can get around this limitation by manually adding a <code>main</code> that returns
<code>Result&lt;T, E&gt;</code>, because <code>Result&lt;T, E&gt;</code> implements the <code>Termination</code> trait:</p>
<pre><code class="language-ignore">/// A doc test using ?
///
/// ```
/// use std::io;
///
/// fn main() -&gt; io::Result&lt;()&gt; {
///     let mut input = String::new();
///     io::stdin().read_line(&amp;mut input)?;
///     Ok(())
/// }
/// ```
</code></pre>
<p>Together with the <code>#</code> from the section above, you arrive at a solution that
appears to the reader as the initial idea but works with doc tests:</p>
<pre><code class="language-ignore">/// ```
/// use std::io;
/// # fn main() -&gt; io::Result&lt;()&gt; {
/// let mut input = String::new();
/// io::stdin().read_line(&amp;mut input)?;
/// # Ok(())
/// # }
/// ```
</code></pre>
<a class="header" href="print.html#documenting-macros" id="documenting-macros"><h2>Documenting macros</h2></a>
<p>Here’s an example of documenting a macro:</p>
<pre><pre class="playpen"><code class="language-rust">/// Panic with a given message unless an expression evaluates to true.
///
/// # Examples
///
/// ```
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(1 + 1 == 2, “Math is broken.”);
/// # }
/// ```
///
/// ```should_panic
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(true == false, “I’m broken.”);
/// # }
/// ```
#[macro_export]
macro_rules! panic_unless {
    ($condition:expr, $($rest:expr),+) =&gt; ({ if ! $condition { panic!($($rest),+); } });
}
# fn main() {}
</code></pre></pre>
<p>You’ll note three things: we need to add our own <code>extern crate</code> line, so that
we can add the <code>#[macro_use]</code> attribute. Second, we’ll need to add our own
<code>main()</code> as well (for reasons discussed above). Finally, a judicious use of
<code>#</code> to comment out those two things, so they don’t show up in the output.</p>
<a class="header" href="print.html#attributes" id="attributes"><h2>Attributes</h2></a>
<p>There are a few annotations that are useful to help <code>rustdoc</code> do the right
thing when testing your code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// ```ignore
/// fn foo() {
/// ```
# fn foo() {}
#}</code></pre></pre>
<p>The <code>ignore</code> directive tells Rust to ignore your code. This is almost never
what you want, as it's the most generic. Instead, consider annotating it
with <code>text</code> if it's not code, or using <code>#</code>s to get a working example that
only shows the part you care about.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// ```should_panic
/// assert!(false);
/// ```
# fn foo() {}
#}</code></pre></pre>
<p><code>should_panic</code> tells <code>rustdoc</code> that the code should compile correctly, but
not actually pass as a test.</p>
<pre><code class="language-text">/// ```no_run
/// loop {
///     println!(&quot;Hello, world&quot;);
/// }
/// ```
# fn foo() {}
</code></pre>
<p>The <code>no_run</code> attribute will compile your code, but not run it. This is
important for examples such as &quot;Here's how to retrieve a web page,&quot;
which you would want to ensure compiles, but might be run in a test
environment that has no network access.</p>
<pre><code class="language-text">/// ```compile_fail
/// let x = 5;
/// x += 2; // shouldn't compile!
/// ```
</code></pre>
<p><code>compile_fail</code> tells <code>rustdoc</code> that the compilation should fail. If it
compiles, then the test will fail. However please note that code failing
with the current Rust release may work in a future release, as new features
are added.</p>
<a class="header" href="print.html#passes" id="passes"><h1>Passes</h1></a>
<p>Rustdoc has a concept called &quot;passes&quot;. These are transformations that
<code>rustdoc</code> runs on your documentation before producing its final output.</p>
<p>In addition to the passes below, check out the docs for these flags:</p>
<ul>
<li><a href="command-line-arguments.html#--passes-add-more-rustdoc-passes"><code>--passes</code></a></li>
<li><a href="command-line-arguments.html#--no-defaults-dont-run-default-passes"><code>--no-defaults</code></a></li>
</ul>
<a class="header" href="print.html#default-passes" id="default-passes"><h2>Default passes</h2></a>
<p>By default, rustdoc will run some passes, namely:</p>
<ul>
<li><code>strip-hidden</code></li>
<li><code>strip-private</code></li>
<li><code>collapse-docs</code></li>
<li><code>unindent-comments</code></li>
</ul>
<p>However, <code>strip-private</code> implies <code>strip-private-imports</code>, and so effectively,
all passes are run by default.</p>
<a class="header" href="print.html#strip-hidden" id="strip-hidden"><h2><code>strip-hidden</code></h2></a>
<p>This pass implements the <code>#[doc(hidden)]</code> attribute. When this pass runs, it
checks each item, and if it is annotated with this attribute, it removes it
from <code>rustdoc</code>'s output.</p>
<p>Without this pass, these items will remain in the output.</p>
<a class="header" href="print.html#unindent-comments" id="unindent-comments"><h2><code>unindent-comments</code></h2></a>
<p>When you write a doc comment like this:</p>
<pre><code class="language-rust ignore">/// This is a documentation comment.
</code></pre>
<p>There's a space between the <code>///</code> and that <code>T</code>. That spacing isn't intended
to be a part of the output; it's there for humans, to help separate the doc
comment syntax from the text of the comment. This pass is what removes that
space.</p>
<p>The exact rules are left under-specified so that we can fix issues that we find.</p>
<p>Without this pass, the exact number of spaces is preserved.</p>
<a class="header" href="print.html#collapse-docs" id="collapse-docs"><h2><code>collapse-docs</code></h2></a>
<p>With this pass, multiple <code>#[doc]</code> attributes are converted into one single
documentation string.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">#[doc = &quot;This is the first line.&quot;]
#[doc = &quot;This is the second line.&quot;]
</code></pre>
<p>Gets collapsed into a single doc string of</p>
<pre><code class="language-text">This is the first line.
This is the second line.
</code></pre>
<a class="header" href="print.html#strip-private" id="strip-private"><h2><code>strip-private</code></h2></a>
<p>This removes documentation for any non-public items, so for example:</p>
<pre><code class="language-rust ignore">/// These are private docs.
struct Private;

/// These are public docs.
pub struct Public;
</code></pre>
<p>This pass removes the docs for <code>Private</code>, since they're not public.</p>
<p>This pass implies <code>strip-priv-imports</code>.</p>
<a class="header" href="print.html#strip-priv-imports" id="strip-priv-imports"><h2><code>strip-priv-imports</code></h2></a>
<p>This is the same as <code>strip-private</code>, but for <code>extern crate</code> and <code>use</code>
statements instead of items.</p>
<a class="header" href="print.html#unstable-features" id="unstable-features"><h1>Unstable features</h1></a>
<p>Rustdoc is under active developement, and like the Rust compiler, some features are only available
on the nightly releases. Some of these are new and need some more testing before they're able to get
released to the world at large, and some of them are tied to features in the Rust compiler that are
themselves unstable. Several features here require a matching <code>#![feature(...)]</code> attribute to
enable, and thus are more fully documented in the <a href="../unstable-book/index.html">Unstable Book</a>. Those sections will link over
there as necessary.</p>
<a class="header" href="print.html#nightly-gated-functionality" id="nightly-gated-functionality"><h2>Nightly-gated functionality</h2></a>
<p>These features just require a nightly build to operate. Unlike the other features on this page,
these don't need to be &quot;turned on&quot; with a command-line flag or a <code>#![feature(...)]</code> attribute in
your crate. This can give them some subtle fallback modes when used on a stable release, so be
careful!</p>
<a class="header" href="print.html#error-numbers-for-compile-fail-doctests" id="error-numbers-for-compile-fail-doctests"><h3>Error numbers for <code>compile-fail</code> doctests</h3></a>
<p>As detailed in <a href="documentation-tests.html#attributes">the chapter on documentation tests</a>, you can add a
<code>compile_fail</code> attribute to a doctest to state that the test should fail to compile. However, on
nightly, you can optionally add an error number to state that a doctest should emit a specific error
number:</p>
<pre><code class="language-markdown">```compile_fail,E0044
extern { fn some_func&lt;T&gt;(x: T); }
```
</code></pre>
<p>This is used by the error index to ensure that the samples that correspond to a given error number
properly emit that error code. However, these error codes aren't guaranteed to be the only thing
that a piece of code emits from version to version, so this is unlikely to be stabilized in the
future.</p>
<p>Attempting to use these error numbers on stable will result in the code sample being interpreted as
plain text.</p>
<a class="header" href="print.html#linking-to-items-by-type" id="linking-to-items-by-type"><h3>Linking to items by type</h3></a>
<p>As designed in <a href="https://github.com/rust-lang/rfcs/pull/1946">RFC 1946</a>, Rustdoc can parse paths to items when you use them as links. To resolve
these type names, it uses the items currently in-scope, either by declaration or by <code>use</code> statement.
For modules, the &quot;active scope&quot; depends on whether the documentation is written outside the module
(as <code>///</code> comments on the <code>mod</code> statement) or inside the module (at <code>//!</code> comments inside the file
or block). For all other items, it uses the enclosing module's scope.</p>
<p>For example, in the following code:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Does the thing.
pub fn do_the_thing(_: SomeType) {
    println!(&quot;Let's do the thing!&quot;);
}

/// Token you use to [`do_the_thing`].
pub struct SomeType;
#}</code></pre></pre>
<p>The link to <code>[`do_the_thing`]</code> in <code>SomeType</code>'s docs will properly link to the page for <code>fn do_the_thing</code>. Note that here, rustdoc will insert the link target for you, but manually writing the
target out also works:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod some_module {
    /// Token you use to do the thing.
    pub struct SomeStruct;
}

/// Does the thing. Requires one [`SomeStruct`] for the thing to work.
///
/// [`SomeStruct`]: some_module::SomeStruct
pub fn do_the_thing(_: some_module::SomeStruct) {
    println!(&quot;Let's do the thing!&quot;);
}
#}</code></pre></pre>
<p>For more details, check out <a href="https://github.com/rust-lang/rfcs/pull/1946">the RFC</a>, and see <a href="https://github.com/rust-lang/rust/issues/43466">the tracking issue</a> for more
information about what parts of the feature are available.</p>
<a class="header" href="print.html#extensions-to-the-doc-attribute" id="extensions-to-the-doc-attribute"><h2>Extensions to the <code>#[doc]</code> attribute</h2></a>
<p>These features operate by extending the <code>#[doc]</code> attribute, and thus can be caught by the compiler
and enabled with a <code>#![feature(...)]</code> attribute in your crate.</p>
<a class="header" href="print.html#documenting-platform-feature-specific-information" id="documenting-platform-feature-specific-information"><h3>Documenting platform-/feature-specific information</h3></a>
<p>Because of the way Rustdoc documents a crate, the documentation it creates is specific to the target
rustc compiles for. Anything that's specific to any other target is dropped via <code>#[cfg]</code> attribute
processing early in the compilation process. However, Rustdoc has a trick up its sleeve to handle
platform-specific code if it <em>does</em> receive it.</p>
<p>Because Rustdoc doesn't need to fully compile a crate to binary, it replaces function bodies with
<code>loop {}</code> to prevent having to process more than necessary. This means that any code within a
function that requires platform-specific pieces is ignored. Combined with a special attribute,
<code>#[doc(cfg(...))]</code>, you can tell Rustdoc exactly which platform something is supposed to run on,
ensuring that doctests are only run on the appropriate platforms.</p>
<p>The <code>#[doc(cfg(...))]</code> attribute has another effect: When Rustdoc renders documentation for that
item, it will be accompanied by a banner explaining that the item is only available on certain
platforms.</p>
<p>As mentioned earlier, getting the items to Rustdoc requires some extra preparation. The standard
library adds a <code>--cfg dox</code> flag to every Rustdoc command, but the same thing can be accomplished by
adding a feature to your Cargo.toml and adding <code>--feature dox</code> (or whatever you choose to name the
feature) to your <code>cargo doc</code> calls.</p>
<p>Either way, once you create an environment for the documentation, you can start to augment your
<code>#[cfg]</code> attributes to allow both the target platform <em>and</em> the documentation configuration to leave
the item in. For example, <code>#[cfg(any(windows, feature = &quot;dox&quot;))]</code> will preserve the item either on
Windows or during the documentation process. Then, adding a new attribute <code>#[doc(cfg(windows))]</code>
will tell Rustdoc that the item is supposed to be used on Windows. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(doc_cfg)]

#fn main() {
/// Token struct that can only be used on Windows.
#[cfg(any(windows, feature = &quot;dox&quot;))]
#[doc(cfg(windows))]
pub struct WindowsToken;

/// Token struct that can only be used on Unix.
#[cfg(any(unix, feature = &quot;dox&quot;))]
#[doc(cfg(unix))]
pub struct UnixToken;
#}</code></pre></pre>
<p>In this sample, the tokens will only appear on their respective platforms, but they will both appear
in documentation.</p>
<p><code>#[doc(cfg(...))]</code> was introduced to be used by the standard library and currently requires the
<code>#![feature(doc_cfg)]</code> feature gate. For more information, see <a href="../unstable-book/language-features/doc-cfg.html">its chapter in the Unstable
Book</a> and <a href="https://github.com/rust-lang/rust/issues/43781">its tracking issue</a>.</p>
<a class="header" href="print.html#adding-your-trait-to-the-important-traits-dialog" id="adding-your-trait-to-the-important-traits-dialog"><h3>Adding your trait to the &quot;Important Traits&quot; dialog</h3></a>
<p>Rustdoc keeps a list of a few traits that are believed to be &quot;fundamental&quot; to a given type when
implemented on it. These traits are intended to be the primary interface for their types, and are
often the only thing available to be documented on their types. For this reason, Rustdoc will track
when a given type implements one of these traits and call special attention to it when a function
returns one of these types. This is the &quot;Important Traits&quot; dialog, visible as a circle-i button next
to the function, which, when clicked, shows the dialog.</p>
<p>In the standard library, the traits that qualify for inclusion are <code>Iterator</code>, <code>io::Read</code>, and
<code>io::Write</code>. However, rather than being implemented as a hard-coded list, these traits have a
special marker attribute on them: <code>#[doc(spotlight)]</code>. This means that you could apply this
attribute to your own trait to include it in the &quot;Important Traits&quot; dialog in documentation.</p>
<p>The <code>#[doc(spotlight)]</code> attribute currently requires the <code>#![feature(doc_spotlight)]</code> feature gate.
For more information, see <a href="../unstable-book/language-features/doc-spotlight.html">its chapter in the Unstable Book</a> and <a href="https://github.com/rust-lang/rust/issues/45040">its tracking
issue</a>.</p>
<a class="header" href="print.html#exclude-certain-dependencies-from-documentation" id="exclude-certain-dependencies-from-documentation"><h3>Exclude certain dependencies from documentation</h3></a>
<p>The standard library uses several dependencies which, in turn, use several types and traits from the
standard library. In addition, there are several compiler-internal crates that are not considered to
be part of the official standard library, and thus would be a distraction to include in
documentation. It's not enough to exclude their crate documentation, since information about trait
implementations appears on the pages for both the type and the trait, which can be in different
crates!</p>
<p>To prevent internal types from being included in documentation, the standard library adds an
attribute to their <code>extern crate</code> declarations: <code>#[doc(masked)]</code>. This causes Rustdoc to &quot;mask out&quot;
types from these crates when building lists of trait implementations.</p>
<p>The <code>#[doc(masked)]</code> attribute is intended to be used internally, and requires the
<code>#![feature(doc_masked)]</code> feature gate.  For more information, see <a href="../unstable-book/language-features/doc-masked.html">its chapter in the Unstable
Book</a> and <a href="https://github.com/rust-lang/rust/issues/44027">its tracking issue</a>.</p>
<a class="header" href="print.html#include-external-files-as-api-documentation" id="include-external-files-as-api-documentation"><h3>Include external files as API documentation</h3></a>
<p>As designed in <a href="https://github.com/rust-lang/rfcs/pull/1990">RFC 1990</a>, Rustdoc can read an external file to use as a type's documentation. This
is useful if certain documentation is so long that it would break the flow of reading the source.
Instead of writing it all inline, writing <code>#[doc(include = &quot;sometype.md&quot;)]</code> (where <code>sometype.md</code> is
a file adjacent to the <code>lib.rs</code> for the crate) will ask Rustdoc to instead read that file and use it
as if it were written inline.</p>
<p><code>#[doc(include = &quot;...&quot;)]</code> currently requires the <code>#![feature(external_doc)]</code> feature gate. For more
information, see <a href="../unstable-book/language-features/external-doc.html">its chapter in the Unstable Book</a> and <a href="https://github.com/rust-lang/rust/issues/44732">its tracking
issue</a>.</p>
<a class="header" href="print.html#unstable-command-line-arguments" id="unstable-command-line-arguments"><h2>Unstable command-line arguments</h2></a>
<p>These features are enabled by passing a command-line flag to Rustdoc, but the flags in question are
themselves marked as unstable. To use any of these options, pass <code>-Z unstable-options</code> as well as
the flag in question to Rustdoc on the command-line. To do this from Cargo, you can either use the
<code>RUSTDOCFLAGS</code> environment variable or the <code>cargo rustdoc</code> command.</p>
<a class="header" href="print.html#a--markdown-before-content-include-rendered-markdown-before-the-content" id="a--markdown-before-content-include-rendered-markdown-before-the-content"><h3><code>--markdown-before-content</code>: include rendered Markdown before the content</h3></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --markdown-before-content extra.md
$ rustdoc README.md -Z unstable-options --markdown-before-content extra.md
</code></pre>
<p>Just like <code>--html-before-content</code>, this allows you to insert extra content inside the <code>&lt;body&gt;</code> tag
but before the other content <code>rustdoc</code> would normally produce in the rendered documentation.
However, instead of directly inserting the file verbatim, <code>rustdoc</code> will pass the files through a
Markdown renderer before inserting the result into the file.</p>
<a class="header" href="print.html#a--markdown-after-content-include-rendered-markdown-after-the-content" id="a--markdown-after-content-include-rendered-markdown-after-the-content"><h3><code>--markdown-after-content</code>: include rendered Markdown after the content</h3></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --markdown-after-content extra.md
$ rustdoc README.md -Z unstable-options --markdown-after-content extra.md
</code></pre>
<p>Just like <code>--html-after-content</code>, this allows you to insert extra content before the <code>&lt;/body&gt;</code> tag
but after the other content <code>rustdoc</code> would normally produce in the rendered documentation.
However, instead of directly inserting the file verbatim, <code>rustdoc</code> will pass the files through a
Markdown renderer before inserting the result into the file.</p>
<a class="header" href="print.html#a--playground-url-control-the-location-of-the-playground" id="a--playground-url-control-the-location-of-the-playground"><h3><code>--playground-url</code>: control the location of the playground</h3></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --playground-url https://play.rust-lang.org/
</code></pre>
<p>When rendering a crate's docs, this flag gives the base URL of the Rust Playground, to use for
generating <code>Run</code> buttons. Unlike <code>--markdown-playground-url</code>, this argument works for standalone
Markdown files <em>and</em> Rust crates. This works the same way as adding <code>#![doc(html_playground_url = &quot;url&quot;)]</code> to your crate root, as mentioned in <a href="the-doc-attribute.html#html_playground_url">the chapter about the <code>#[doc]</code>
attribute</a>. Please be aware that the official Rust Playground at
https://play.rust-lang.org does not have every crate available, so if your examples require your
crate, make sure the playground you provide has your crate available.</p>
<p>If both <code>--playground-url</code> and <code>--markdown-playground-url</code> are present when rendering a standalone
Markdown file, the URL given to <code>--markdown-playground-url</code> will take precedence. If both
<code>--playground-url</code> and <code>#![doc(html_playground_url = &quot;url&quot;)]</code> are present when rendering crate docs,
the attribute will take precedence.</p>
<a class="header" href="print.html#a--crate-version-control-the-crate-version" id="a--crate-version-control-the-crate-version"><h3><code>--crate-version</code>: control the crate version</h3></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --crate-version 1.3.37
</code></pre>
<p>When <code>rustdoc</code> receives this flag, it will print an extra &quot;Version (version)&quot; into the sidebar of
the crate root's docs. You can use this flag to differentiate between different versions of your
library's documentation.</p>
<a class="header" href="print.html#a--linker-control-the-linker-used-for-documentation-tests" id="a--linker-control-the-linker-used-for-documentation-tests"><h3><code>--linker</code>: control the linker used for documentation tests</h3></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc --test src/lib.rs -Z unstable-options --linker foo
$ rustdoc --test README.md -Z unstable-options --linker foo
</code></pre>
<p>When <code>rustdoc</code> runs your documentation tests, it needs to compile and link the tests as executables
before running them. This flag can be used to change the linker used on these executables. It's
equivalent to passing <code>-C linker=foo</code> to <code>rustc</code>.</p>
<a class="header" href="print.html#a--sort-modules-by-appearance-control-how-items-on-module-pages-are-sorted" id="a--sort-modules-by-appearance-control-how-items-on-module-pages-are-sorted"><h3><code>--sort-modules-by-appearance</code>: control how items on module pages are sorted</h3></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --sort-modules-by-appearance
</code></pre>
<p>Ordinarily, when <code>rustdoc</code> prints items in module pages, it will sort them alphabetically (taking
some consideration for their stability, and names that end in a number). Giving this flag to
<code>rustdoc</code> will disable this sorting and instead make it print the items in the order they appear in
the source.</p>
<a class="header" href="print.html#a--themes-provide-additional-themes" id="a--themes-provide-additional-themes"><h3><code>--themes</code>: provide additional themes</h3></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --themes theme.css
</code></pre>
<p>Giving this flag to <code>rustdoc</code> will make it copy your theme into the generated crate docs and enable
it in the theme selector. Note that <code>rustdoc</code> will reject your theme file if it doesn't style
everything the &quot;light&quot; theme does. See <code>--theme-checker</code> below for details.</p>
<a class="header" href="print.html#a--theme-checker-verify-theme-css-for-validity" id="a--theme-checker-verify-theme-css-for-validity"><h3><code>--theme-checker</code>: verify theme CSS for validity</h3></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc -Z unstable-options --theme-checker theme.css
</code></pre>
<p>Before including your theme in crate docs, <code>rustdoc</code> will compare all the CSS rules it contains
against the &quot;light&quot; theme included by default. Using this flag will allow you to see which rules are
missing if <code>rustdoc</code> rejects your theme.</p>
<a class="header" href="print.html#a--resource-suffix-modifying-the-name-of-cssjavascript-in-crate-docs" id="a--resource-suffix-modifying-the-name-of-cssjavascript-in-crate-docs"><h3><code>--resource-suffix</code>: modifying the name of CSS/JavaScript in crate docs</h3></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --resource-suffix suf
</code></pre>
<p>When rendering docs, <code>rustdoc</code> creates several CSS and JavaScript files as part of the output. Since
all these files are linked from every page, changing where they are can be cumbersome if you need to
specially cache them. This flag will rename all these files in the output to include the suffix in
the filename. For example, <code>light.css</code> would become <code>light-suf.css</code> with the above command.</p>
<a class="header" href="print.html#a--display-warnings-display-warnings-when-documenting-or-running-documentation-tests" id="a--display-warnings-display-warnings-when-documenting-or-running-documentation-tests"><h3><code>--display-warnings</code>: display warnings when documenting or running documentation tests</h3></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --display-warnings
$ rustdoc --test src/lib.rs -Z unstable-options --display-warnings
</code></pre>
<p>The intent behind this flag is to allow the user to see warnings that occur within their library or
their documentation tests, which are usually suppressed. However, <a href="https://github.com/rust-lang/rust/issues/41574">due to a
bug</a>, this flag doesn't 100% work as intended. See the linked issue for
details.</p>
<a class="header" href="print.html#a--edition-control-the-edition-of-docs-and-doctests" id="a--edition-control-the-edition-of-docs-and-doctests"><h3><code>--edition</code>: control the edition of docs and doctests</h3></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z unstable-options --edition 2018
$ rustdoc --test src/lib.rs -Z unstable-options --edition 2018
</code></pre>
<p>This flag allows rustdoc to treat your rust code as the given edition. It will compile doctests with
the given edition as well. As with <code>rustc</code>, the default edition that <code>rustdoc</code> will use is <code>2015</code>
(the first edition).</p>
<a class="header" href="print.html#a-z-force-unstable-if-unmarked" id="a-z-force-unstable-if-unmarked"><h3><code>-Z force-unstable-if-unmarked</code></h3></a>
<p>Using this flag looks like this:</p>
<pre><code class="language-bash">$ rustdoc src/lib.rs -Z force-unstable-if-unmarked
</code></pre>
<p>This is an internal flag intended for the standard library and compiler that applies an
<code>#[unstable]</code> attribute to any dependent crate that doesn't have another stability attribute. This
allows <code>rustdoc</code> to be able to generate documentation for the compiler crates and the standard
library, as an equivalent command-line argument is provided to <code>rustc</code> when building those crates.</p>
<a class="header" href="print.html#doc_alias-feature" id="doc_alias-feature"><h3><code>doc_alias</code> feature</h3></a>
<p>This feature allows you to add alias(es) to an item when using the <code>rustdoc</code> search through the
<code>doc(alias)</code> attribute. Example:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#![feature(doc_alias)]

#fn main() {
#[doc(alias = &quot;x&quot;)]
#[doc(alias = &quot;big&quot;)]
pub struct BigX;
#}</code></pre></pre>
<p>Then, when looking for it through the <code>rustdoc</code> search, if you enter &quot;x&quot; or
&quot;big&quot;, search will show the <code>BigX</code> struct first.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
